<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>atri.ac • flowfield</title>
<style>
  html,body{margin:0;height:100%;background:#050510;overflow:hidden}
  canvas{display:block;width:100%;height:100%}
  .hud{
    position:fixed;left:12px;bottom:12px;color:#dbeafe;font-family:system-ui,Inter,Arial,sans-serif;
    font-size:12px;line-height:1.35;background:rgba(5,5,20,.35);backdrop-filter:blur(6px);
    border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:10px 12px;user-select:none
  }
  .hud b{color:#a5f3fc}
  .pulse{animation:pulse 1.8s ease-in-out infinite}
  @keyframes pulse{0%{opacity:.55}50%{opacity:1}100%{opacity:.55}}
</style>
</head>
<body>
<canvas id="fx"></canvas>
<div class="hud">
  <div><b>atri.ac</b> flowfield</div>
  <div class="pulse">click or press <b>C</b> to change colors</div>
  <div>press <b>Space</b> to burst • press <b>H</b> to hide UI</div>
  <div>drag to attract • <b>1-5</b> quality • <b>R</b> reset</div>
</div>

<script>
/* ========= Simplex Noise (2D) =========
   Adapted from Stefan Gustavson public domain reference */
const Simplex2D=(function(){
  const grad3=new Float32Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]);
  const p=new Uint8Array(256); for(let i=0;i<256;i++) p[i]=i;
  function seed(s){
    let n=s>>>0; for(let i=255;i>0;i--){n=(n*1664525+1013904223)>>>0; const r=n%(i+1); const t=p[i]; p[i]=p[r]; p[r]=t;}
    perm.set(p); permMod12.set(p.map(v=>v%12));
  }
  const perm=new Uint8Array(512), permMod12=new Uint8Array(512); seed(1337);
  function noise(xin,yin){
    const F2=0.5*(Math.sqrt(3)-1), s=(xin+yin)*F2, i=Math.floor(xin+s), j=Math.floor(yin+s);
    const G2=(3-Math.sqrt(3))/6, t=(i+j)*G2, X0=i-t, Y0=j-t, x0=xin-X0, y0=yin-Y0;
    let i1, j1; if(x0>y0){i1=1;j1=0;} else {i1=0;j1=1;}
    const x1=x0-i1+G2, y1=y0-j1+G2, x2=x0-1+2*G2, y2=y0-1+2*G2;
    const ii=i&255, jj=j&255;
    const gi0=permMod12[ii+perm[jj]]*2, gi1=permMod12[ii+i1+perm[jj+j1]]*2, gi2=permMod12[ii+1+perm[jj+1]]*2;
    let n0=0,n1=0,n2=0, t0=0.5-x0*x0-y0*y0; if(t0>=0){t0*=t0; n0=t0*t0*(grad3[gi0]*x0+grad3[gi0+1]*y0);}
    let t1=0.5-x1*x1-y1*y1; if(t1>=0){t1*=t1; n1=t1*t1*(grad3[gi1]*x1+grad3[gi1+1]*y1);}
    let t2=0.5-x2*x2-y2*y2; if(t2>=0){t2*=t2; n2=t2*t2*(grad3[gi2]*x2+grad3[gi2+1]*y2);}
    return 70*(n0+n1+n2);
  }
  noise.seed=seed; return noise;
})();

/* ========= Flow Field ========= */
const canvas=document.getElementById('fx');
const ctx=canvas.getContext('2d');
let DPR=Math.min(devicePixelRatio||1,2);
let W,H,particles=[],fieldScale=0.0017, time=0, zInc=0.0012;
let mouse={x:0,y:0,down:false};
let quality=4; // 1..5
const palettes=[
  // cyan violet emerald
  t=>`hsla(${200+60*Math.sin(t)},100%,70%,.7)`,
  // sunrise
  t=>`hsla(${20+40*Math.sin(t)},90%,65%,.7)`,
  // aurora
  t=>`hsla(${120+80*Math.sin(t*0.8)},80%,70%,.75)`,
  // neon ocean
  t=>`hsla(${180+30*Math.sin(t*1.2)},100%,60%,.8)`,
  // candy
  t=>`hsla(${300+120*Math.sin(t*0.9)},95%,70%,.75)`
];
let paletteIndex=0;

function resize(){
  DPR=Math.min(devicePixelRatio||1,2);
  W=canvas.width=Math.floor(innerWidth*DPR);
  H=canvas.height=Math.floor(innerHeight*DPR);
  canvas.style.width=innerWidth+'px';
  canvas.style.height=innerHeight+'px';
  resetParticles();
}
window.addEventListener('resize',resize); resize();

function resetParticles(){
  const count=Math.floor((W*H)/(1400/(quality*quality))); // scales with quality and screen
  particles.length=0;
  for(let i=0;i<count;i++){
    particles.push({
      x:Math.random()*W, y:Math.random()*H,
      vx:0, vy:0,
      life: 200+Math.random()*600,
      hueSeed:Math.random()*Math.PI*2
    });
  }
  ctx.clearRect(0,0,W,H);
  // prefill a faint background
  ctx.fillStyle='rgba(5,5,16,1)'; ctx.fillRect(0,0,W,H);
}

/* Vector field from layered simplex noise */
function field(x,y,t){
  const n1=Simplex2D(x*fieldScale,y*fieldScale + t*0.35);
  const n2=Simplex2D((x+1000)*fieldScale*0.6,(y-1000)*fieldScale*0.6 + t*0.22);
  const a=(n1*1.2 + n2*0.8) * Math.PI; // angle
  const m=0.6+0.4*Math.sin(n1*2.0 + t*0.5); // magnitude
  return {ax:Math.cos(a)*m, ay:Math.sin(a)*m};
}

/* Interaction: soft attractor around mouse when held */
function attract(p){
  const dx=(mouse.x - p.x), dy=(mouse.y - p.y);
  const d2=dx*dx+dy*dy; if(d2<1) return;
  const f= Math.min(1/(d2*0.000002), 0.2);
  p.vx += dx*f; p.vy += dy*f;
}

/* Draw trail as line segments with additive glow */
function step(){
  requestAnimationFrame(step);
  time += zInc;

  // slow background fade to create trails
  ctx.globalCompositeOperation='source-over';
  ctx.fillStyle='rgba(5,5,18,0.06)'; // low alpha to keep long trails
  ctx.fillRect(0,0,W,H);

  ctx.globalCompositeOperation='lighter';
  const colorFn=palettes[paletteIndex%palettes.length];

  for(let i=0;i<particles.length;i++){
    const p=particles[i];
    // field acceleration
    const v=field(p.x,p.y,time);
    p.vx += v.ax*0.35;
    p.vy += v.ay*0.35;

    // mouse attractor
    if(mouse.down) attract(p);

    // mild viscosity
    p.vx*=0.965; p.vy*=0.965;

    const nx=p.x+p.vx, ny=p.y+p.vy;

    // wrap edges
    if(nx<0||nx>W||ny<0||ny>H){ p.x=Math.random()*W; p.y=Math.random()*H; p.vx=p.vy=0; p.life=200+Math.random()*600; continue; }

    // color varies by particle phase and global time
    const t = p.hueSeed + time*1.6;
    ctx.strokeStyle=colorFn(Math.sin(t));
    ctx.lineWidth= DPR * (0.6 + 0.6*Math.sin(t*2.0));
    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(nx,ny); ctx.stroke();

    p.x=nx; p.y=ny;
    if(--p.life<=0){ // respawn softly
      p.x=Math.random()*W; p.y=Math.random()*H; p.vx=p.vy=0; p.life=200+Math.random()*600;
    }
  }
}
step();

/* Mouse */
function setMouse(e){
  const rect=canvas.getBoundingClientRect();
  mouse.x=(e.clientX-rect.left)*DPR;
  mouse.y=(e.clientY-rect.top)*DPR;
}
window.addEventListener('mousemove',setMouse);
window.addEventListener('touchmove',e=>{if(e.touches[0]) setMouse(e.touches[0]);},{passive:true});
window.addEventListener('mousedown',e=>{mouse.down=true; setMouse(e); paletteIndex++; burst(1200);});
window.addEventListener('mouseup',()=>{mouse.down=false;});
window.addEventListener('touchstart',e=>{mouse.down=true; if(e.touches[0]) setMouse(e.touches[0]); paletteIndex++; burst(1200);},{passive:true});
window.addEventListener('touchend',()=>{mouse.down=false;});

/* Burst: quick outward kick for a wave effect */
function burst(ms=900){
  for(const p of particles){
    const dx=p.x - mouse.x, dy=p.y - mouse.y;
    const d=Math.hypot(dx,dy)+0.0001;
    const power = 7/(1+d*0.01);
    p.vx += (dx/d)*power;
    p.vy += (dy/d)*power;
  }
  // momentary faster z to morph the field
  const base=zInc; zInc=base*3;
  setTimeout(()=> zInc=base, ms);
}

/* Keys */
window.addEventListener('keydown',e=>{
  if(e.code==='Space'){ e.preventDefault(); burst(); }
  if(e.key==='c' || e.key==='C'){ paletteIndex++; }
  if(e.key==='h' || e.key==='H'){ document.querySelector('.hud').style.display =
      (document.querySelector('.hud').style.display==='none') ? 'block' : 'none'; }
  if(e.key==='r' || e.key==='R'){ resetParticles(); }
  if(/[1-5]/.test(e.key)){ quality=parseInt(e.key,10); resetParticles(); }
});

/* Nice background hue drift */
let hueBase=210, hueTimer=0;
setInterval(()=>{ hueBase=(hueBase+0.3)%360;
  document.body.style.background=`hsl(${hueBase},40%,6%)`;
  // small palette auto shift every 10 seconds
  if((++hueTimer)%600===0) paletteIndex++;
},50);

/* Seed noise with time so each load is unique yet smooth */
Simplex2D.seed((Date.now()&0xffffffff) ^ 0x9e3779b9);
</script>
</body>
</html>
